<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (zlist.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ zlist</nav><h1 id="zlist---lazy-lists-for-ocaml"><a href="#zlist---lazy-lists-for-ocaml" class="anchor"></a><code>zlist</code> - Lazy lists for OCaml</h1><p>This is version 0.5.0, which is released under the terms of the Apache-2.0 license.</p><p><code>zlist</code> is copyright 2016 by Jesse Haber-Kucharsky.</p><nav class="toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#examples">Examples</a></li><li><a href="#entry-point">Entry point</a></li><li><a href="#acknowledgements">Acknowledgements</a></li></ul></nav></header><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>A lazy list is like an OCaml <code>list</code>, except that next element is lazily computed. These lists behave like the <code>List</code> type in Haskell.</p><p>This structure allows allows arbitrary transformations to be executed without forcing each intermediate representation in memory.</p><p>Another interesting property of lazy lists is that infinite structures can be constructed without being evaluated.</p><p>For example, this is an infinite list of the value <code>0</code>:</p><pre><code class="ml">let zeros = Zlist.continually 0 </code></pre><p>A similar structure to a lazy list is the (now) standard <code>Seq.t</code> type, which differs from lazy lists in that it is defined via a function <code>unit -&gt; 'a</code> (a &quot;thunk&quot;) instead of as a lazy value.</p><p>For applications in which <code>zlist</code> would be useful, it's likely that <code>Seq.t</code> is a better option due to interoperability with the wider OCaml ecosystem. Thus, the value in this package is mostly educational.</p><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>Each of these examples assumes that</p><pre><code class="ml">open Zlist </code></pre><p>has been executed.</p><ul><li>Generate an infinite sequence of even numbers and sample some of them:</li></ul><pre><code class="ml">let evens = enum_from 0 |&gt; map (fun x -&gt; 2 * x) in
evens |&gt; take 4 |&gt; strict</code></pre><pre><code class="ml">- : int list = [0; 2; 4; 6] </code></pre><ul><li>Compute an infinite list of Fibonacci numbers and sample 8 of them:</li></ul><pre><code class="ml">let fibs = iterate (0, 1) (fun (a, b) -&gt; (b, a + b)) |&gt; map snd in
fibs |&gt; take 8 |&gt; strict</code></pre><pre><code class="ml">- : int list = [1; 1; 2; 3; 5; 8; 13; 21] </code></pre><ul><li>A Quicksort-like algorithm:</li></ul><pre><code class="ml">let ( ++ ) = concat in

let rec sort = function
  | lazy Nil -&gt; lazy Nil
  | lazy (Cons (x, t)) -&gt;
      let smaller = filter (fun y -&gt; y &lt; x) t in
      let greater = filter (fun y -&gt; y &gt;= x) t in
      sort smaller ++ unit x ++ sort greater
in

sort (items [10; 2; 8; 5; 1; 0; 20; 3]) |&gt; strict</code></pre><pre><code class="ml">- : int list = [0; 1; 2; 3; 5; 8; 10; 20] </code></pre><h2 id="entry-point"><a href="#entry-point" class="anchor"></a>Entry point</h2><p>The entry point for the <code>zlist</code> package is the <a href="Zlist/index.html"><code>Zlist</code></a> module, which defines the type of a lazy list, <a href="Zlist/index.html#type-t"><code>Zlist.t</code></a>.</p><h2 id="acknowledgements"><a href="#acknowledgements" class="anchor"></a>Acknowledgements</h2><p>This implementation is heavily inspired by &quot;Functional Programming in Scala&quot;, by Chiusano and Bjarnason (2014).</p></div></body></html>